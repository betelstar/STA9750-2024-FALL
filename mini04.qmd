---
title: "Mini-Project #04: Monte Carlo-Informed Selection of CUNY Retirement Plans"
format:
  html:
    code-link: true
echo: true
editor: 
  markdown: 
    wrap: 72
---




```{r}
#| echo: false
#| warning: false
#| message: false
options(repos = c(CRAN = "https://cloud.r-project.org"))

```

## Set-Up and Exploration

### Data Acquisition

To begin your Monte Carlo analysis, you will need historical data
covering (at a minimum) the following:

-   Wage growth
-   Inflation
-   US Equity Market total returns
-   International Equity Market total returns
-   Bond market total returns
-   Short-term debt returns[^4]

[^4]: For short-term debt, it may be easiest to pick a key short-term
    benchmark, *e.g.*, the 2-year US Treasury yield. The world of
    "short-term debt" is rather wide and varied.

::: {.callout-tip title="Task 3: Data Acquisition"}
Identify and download historical data series for each of the above
inputs to your Monte Carlo analysis. If necessary, "downsample" each
series to a monthly frequency and join them together in a `data.frame`.

You must use at least one data series from `AlphaVantage` and one from
`FRED`. You must use the APIs of each service to access this data and,
as noted above, you need to use the "raw" API, relying only on the
`httr2` package (or similar) and not wrapper packages like `quantmod` or
`alphavantager`.
:::

Note that, for each of these quantities, there are many
possibly-relevant data series: *e.g.*, for inflation, you might compare
CPI, core CPI, PCE, both nationally and, if available, in the NY metro
area. You may select any series you feel best captures these for a
potential CUNY employee. For the market returns, it may be easiest to
identify a suitable index ETF and compute its (dividend-adjusted)
returns as a proxy for market returns.

In any historically-based financial projection, there is a trade-off
between having enough history to capture sufficient market cycles and
having only relevant data in your training set. I'd recommend using
around 15-20 years of data for this project.

### Investigation and Visualization of Input Data

::: {.callout-tip title="Task 4: Initial Analysis"}
After you have acquired your input data, perform some basic exploratory
data analysis to identify key properties of your data. You may choose to
measure the correlation among factors, long-term averages, variances,
*etc.* Your analysis should include at least one table and one figure.

As part of your analysis, be sure to compute the long-run monthly
average value of each series. You will use these in a later task.
:::

### Historical Comparison of TRS and ORP

::: {.callout-tip title="Task 5: Historical Comparison"}
Now that you have acquired data, implement the TRS and ORP formulas
above and compare the value of each of them for the first month of
retirement. To do this, you may assume that your hypothetical employee:

-   Joined CUNY in the first month of the historical data
-   Retired from CUNY at the end of the final month of data

You will need to select a starting salary for your employee. Use
historical data for wage growth and inflation and assume that the TRS
and ORP parameters did not change over time. (That is, the employee
contribution "brackets" are not inflation adjusted; the employee will
have to make larger contributions as income rises over the span of a 20+
year career.)
:::

### Long-Term Average Analysis

The "first month of retirement" dollar value is interesting, but it
arguably undersells a key strength of the TRS. The TRS *guarantees*
income for life, while the ORP can be exhausted if the employee lives a
very long time in retirement.

::: {.callout-tip title="Task 6: Fixed-Rate Analysis"}
Modify your simulation from the previous section to project an
employee's pension benefit (TRS) or withdrawal amount (ORP) from
retirement until death. (You will need to select an estimated death
age.) In order to implement cost-of-living-adjustments (TRS) and future
market returns (ORP), you can use the long-run averages you computed
previously. This "fixed rate" assumption is rather limiting, but we will
address it below.

As you compare the plans, be sure to consider:

-   Whether the employee runs out of funds before death and/or has funds
    to leave to heirs (ORP only)
-   Average monthly income (TRS vs ORP)
-   Maximum and minimum gap in monthly income between TRS and ORP

As noted above, you can ignore the effect of taxes throughout this
analysis.
:::

### Bootstrap (Monte Carlo) Comparison

Now that you have implemented both the "while working" contributions and
returns (ORP) only as well as the "while retired" benefits of both
plans, we are finally ready to implement our Monte Carlo assessment.

::: {.callout-tip title="Task 7: Monte Carlo Analysis"}
Using your historical data, generate several (at least 200) "bootstrap
histories" suitable for a Monte Carlo analysis. Use bootstrap sampling,
*i.e.* sampling with replacement, to generate values for both the "while
working" and "while retired" periods of the model; you do not need to
assume constant long-term average values for the retirement predictions
any more.

Apply your calculations from the previous two tasks to each of your
simulated bootstrap histories. Compare the *distribution* of TRS and ORP
benefits that these histories generate. You may want to ask questions
like the following:

1)  What is the probability that an ORP employee exhausts their savings
    before death?
2)  What is the probability that an ORP employee has a higher monthly
    income in retirement than a TRS employee?
3)  Is the 4% withdrawal rate actually a good idea or would you
    recommend a different withdrawal rate?

Report your findings to these or other questions of interest in tables
or figures, as appropriate.
:::

## Deliverable: Data-Driven Decision Recommendation

Finally, write up your findings from Task 7 in the form of a
"data-driven recommendation" to a potential CUNY employee. Here, you are
playing the role of a financial advisor, so be sure to consider the
employee's current age and starting salary, expected lifetime, and risk
tolerance. Be sure to suitably convey the uncertainty of your
predictions and the limitations of the bootstrap-history approach used
here.[^5] As you write this, think of what issues would matter most to
you if you were making this decision and address them accordingly.

[^5]: As the SEC requires all advisors to disclaim: Past Performance is
    No Guarantee of Future Results.

## Extra Credit Opportunities

For extra credit, you may make an *interactive* version of your report,
allowing your client to alter the parameters of your simulation and see
how the predictions change.

### Challenge Level: Basic (Up to 5 points Extra Credit)

Perform a "sensitivity analysis" by re-running your previous analysis
under various different input parameters (starting salary, retirement
age, death age, *etc.*) Then use some sort of interactive functionality
to allow the reader to see how the results change.

The
[`manipulateWidgets`](https://cran.r-project.org/web/packages/manipulateWidget/vignettes/manipulateWidgets.html)
package may be useful here, but any sort of in-browser interactive
display will suffice.

Note that, in this model, all the simulations are run by `Quarto` at
`Render` time and the interactivity only controls which simulations are
displayed.

### Challenge Level: Moderate (Up to 10 points Extra Credit)

Use the [`shiny` package](https://shiny.posit.co/r/gallery/) to
implement a reactive dashboard. `shiny` requires use of a server to
perform calculations. The website
[`shinyapps.io`](https://www.shinyapps.io/) provides a free platform to
host the "backend" of your `shiny` dashboard. [This
example](https://shiny.posit.co/r/gallery/application-layout/retirement-simulation/)
may prove useful, but note that the analysis required for this project
(historical resampling) is a bit more advanced than the parametric model
used there.

Under the `shiny` model, a back-end server is running (and re-running)
simulations in real-time in response to user input.

### Challenge Level: Advanced (Up to 20 points Extra Credit)

Use the [`r-shinylive`](https://posit-dev.github.io/r-shinylive/)
framework to create a fully dynamic in-browser simulation dashboard.
This in-development technology allows users to modify and re-run all
simulations *in their browser*, providing the highest level of
flexibility. You can allow users to vary their starting salary,
retirement age, choice of data series, number of Monte Carlo histories,
dates of historical data used for resampling, *etc.*

Note that `r-shinylive` is a new technology and one that remains under
active development. The instructor will not be able to provide support
and assistance debugging it.




To estimate the median of an unknown distribution, we use the sample median. Calculating its variance is complex, so we use bootstrapping instead. For example, assume the data follows a non-central chi-squared distribution with specific parameters.

```{r}
#| echo: false
#| warning: false
#| message: false
set.seed(100)
DATA <- rchisq(250, df=pi, ncp = exp(2))
SAMPLE_MEDIAN <- median(DATA)
SAMPLE_MEDIAN
```
The median of this distribution is too complex for Wikipedia, but we can compute it empirically using a very large sample:

```{r}
#| echo: false
#| warning: false
#| message: false
TRUE_MEDIAN <- median(rchisq(5e7, df=pi, ncp = exp(2)))
TRUE_MEDIAN 
```
So our sample median (10.74) is a bit off from the true median (9.58) but not catastrophically so. How can we estimate the variance? By bootstrapping!

We can implement a bootstrap in dplyr as follows:

```{r}
#| echo: false
#| warning: false
#| message: false
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr", quiet = TRUE)
}
if (!requireNamespace("tidyr", quietly = TRUE)) {
  install.packages("tidyr", quiet = TRUE)
}

suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))

```


```{r}
#| echo: false
#| warning: false
#| message: false
B <- 500 # Number of boostrap samples to create
n <- length(DATA) # Original data size

expand_grid(B = 1:B, 
            n = 1:n) |>
    # Notice here we sample _with replacement_ from DATA
    mutate(x = sample(DATA, n(), replace = TRUE)) |>
    group_by(B) |>
    summarize(f_boot = median(x)) |>
    summarize(var_f = var(f_boot)) |>
    pull(var_f)


```
We can compare this to the CLT-asymptotic variance:

```{r}
#| echo: false
#| warning: false
#| message: false
1/(4 * n * dchisq(TRUE_MEDIAN, df=pi, ncp = exp(2))^2)
```
And, since we’re in simulation land, we also have the true variance:


```{r}
#| echo: false
#| warning: false
#| message: false
var(replicate(10000, {
    median(rchisq(250, df=pi, ncp = exp(2)))
}))

```

When dealing with simple data where each value is independent and similar (IID), bootstrapping is easy—you just use sample(replace=TRUE) to resample. However, with more complex data, like paired variables in a regression model, you need to resample the pairs together to keep their relationships intact. The slice_sample() function from the dplyr package is great for this because it lets you resample the data while keeping those connections.


We generate pairs with a visible, but not precisely linear, relationship.

```{r}
#| echo: false
#| warning: false
#| message: false
x <- rchisq(100, df=3, ncp=2)
y <- x * sin(2 * x) + 15 * log(x)
plot(x, y)


```
The Kendall correlation is easily computed:                  
```{r}
#| echo: false
#| warning: false
#| message: false
cor(x, y, method="kendall")
```

To put a confidence interval on this, we can use a bootstrap with B = 400 replicates:

```{r}
#| echo: false
#| warning: false
#| message: false

stopifnot(length(x) == length(y))
n_samp <- length(x)
n_boot <- 400

# Wrap the pipeline in suppressMessages and suppressWarnings
result <- suppressMessages(suppressWarnings(
    data.frame(x = x, y = y) |>
        slice_sample(n = n_samp * n_boot, replace = TRUE) |>
        mutate(resample_id = rep(1:n_boot, times = n_samp)) |>
        group_by(resample_id) |>
        summarize(kendall_cor = cor(x, y, method = "kendall")) |>
        summarize(var_kendall_cor = var(kendall_cor)) |>
        pull(var_kendall_cor)
))

# Print the result cleanly
cat("We can again compare this to the 'true' sampling variance since we have access to the data-generating model.\n\n[1]", result, "\n")


```
We can again compare this to the “true” sampling variance since we have access to the data-generating model.

```{r}
#| echo: false
#| warning: false
#| message: false
var(replicate(5000, {
    x <- rchisq(100, df=3, ncp=2)
    y <- x * sin(2 * x) + 15 * log(x)
    cor(x, y, method="kendall")
}))

```


```{r}
#| echo: false
#| warning: false
#| message: false
# Open .Renviron in RStudio for editing
file.edit("~/.Renviron")


```

```{r}
#| echo: false
#| warning: false
#| message: false
# Retrieve API keys from environment variables
alpha_vantage_api_key <- Sys.getenv("ALPHA_VANTAGE_API_KEY")
fred_api_key <- Sys.getenv("FRED_API_KEY")

```

```{r}
#| echo: false
#| warning: false
#| message: false

# Suppress messages and warnings during installation
if (!requireNamespace("httr2", quietly = TRUE)) {
  install.packages("httr2", quiet = TRUE)
}
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr", quiet = TRUE)
}
if (!requireNamespace("lubridate", quietly = TRUE)) {
  install.packages("lubridate", quiet = TRUE)
}
if (!requireNamespace("tidyr", quietly = TRUE)) {
  install.packages("tidyr", quiet = TRUE)
}

# Suppress startup messages when loading libraries
suppressPackageStartupMessages({
  library(httr2)
  library(dplyr)
  library(lubridate)
  library(tidyr)
})

```


Step 3: Download Data
Wage Growth and Inflation (FRED)
Use FRED for CPI or Core CPI data as a proxy for inflation and wage growth.


US Equity Market Total Returns (AlphaVantage)
Use AlphaVantage to get adjusted close prices for a US equity index ETF like SPY (S&P 500 ETF).

```{r}
#| echo: false
#| warning: false
#| message: false

library(httr2)
library(lubridate)

# Retrieve API key from environment variable
alpha_vantage_api_key <- Sys.getenv("ALPHA_VANTAGE_API_KEY")

# Function to fetch only monthly closing prices
fetch_monthly_closing_prices <- function(symbol, api_key) {
  response <- request("https://www.alphavantage.co/query") %>%
    req_url_query(
      `function` = "TIME_SERIES_MONTHLY",  # Specify monthly time series
      symbol = symbol,
      apikey = api_key
    ) %>%
    req_perform() %>%
    resp_body_json()
  
  # Extract time series data
  time_series <- response[["Monthly Time Series"]]
  
  # Convert to a data frame with only date and close price, align dates to the first of the month
  data.frame(
    date = floor_date(as.Date(names(time_series)), "month"),  # Align to first day of the month
    close = as.numeric(sapply(time_series, function(x) x[["4. close"]]))
  )
}

# Fetch monthly closing prices for SPY
spy_monthly_closing_prices <- fetch_monthly_closing_prices("SPY", alpha_vantage_api_key)

# Display a preview of the closing prices
head(spy_monthly_closing_prices)


```

```{r}
#| echo: false
#| warning: false
#| message: false

# Function to fetch data from FRED
fetch_fred_data <- function(series_id, api_key) {
  response <- request("https://api.stlouisfed.org/fred/series/observations") %>%
    req_url_query(series_id = series_id, api_key = api_key, file_type = "json") %>%
    req_perform() %>%
    resp_body_json()
  
  # Convert to data frame
  observations <- response$observations
  data.frame(
    date = as.Date(sapply(observations, function(x) x$date)),
    value = as.numeric(sapply(observations, function(x) x$value))
  )
}

# Fetch Consumer Price Index (CPI) as monthly data
cpi_data <- fetch_fred_data("CPIAUCSL", fred_api_key) # Corrected function call

# Fetch 10-Year Treasury Yield (Bonds)
bond_data <- fetch_fred_data("DGS10", fred_api_key) # Corrected function call

# Fetch 2-Year Treasury Yield (Short-Term Debt)
short_term_debt_data <- fetch_fred_data("DGS2", fred_api_key) # Corrected function call

# Preview the datasets
head(cpi_data)
head(bond_data)
head(short_term_debt_data)

```

Step 4: Join and Downsample Data
Join all the data into a single data.frame and downsample to monthly frequency.


Step 1: Summarize Key Properties
Compute the long-term monthly averages, standard deviations, and correlations for your data series.



```{r}
#| echo: false
#| warning: false
#| message: false

library(dplyr)
library(lubridate)

# Process daily bond data into monthly format
bond_data_monthly <- bond_data %>%
  mutate(date = floor_date(date, "month")) %>% # Round to the first of the month
  group_by(date) %>%
  summarize(bond_yield = mean(value, na.rm = TRUE)) # Calculate monthly average

# Process daily short-term debt data into monthly format
short_term_debt_monthly <- short_term_debt_data %>%
  mutate(date = floor_date(date, "month")) %>% # Round to the first of the month
  group_by(date) %>%
  summarize(short_term_yield = mean(value, na.rm = TRUE)) # Calculate monthly average

# Ensure monthly data starts from January 2000
cpi_data <- cpi_data %>% filter(date >= as.Date("2000-01-01"))
spy_monthly_closing_prices <- spy_monthly_closing_prices %>% filter(date >= as.Date("2000-01-01"))
bond_data_monthly <- bond_data_monthly %>% filter(date >= as.Date("2000-01-01"))
short_term_debt_monthly <- short_term_debt_monthly %>% filter(date >= as.Date("2000-01-01"))

# Merge all datasets into a single data frame
monthly_data <- cpi_data %>%
  rename(CPI = value) %>% # Rename CPI variable
  left_join(spy_monthly_closing_prices %>% rename(SPY_CLOSE = close), by = "date") %>%
  left_join(bond_data_monthly %>% rename(`10_Year_Bond` = bond_yield), by = "date") %>%
  left_join(short_term_debt_monthly %>% rename(`2_Year_Bond` = short_term_yield), by = "date")

# Preview the combined data frame with renamed variables
head(monthly_data)



```

```{r}
#| echo: false
#| warning: false
#| message: false
write.csv(monthly_data, "processed_monthly_data.csv", row.names = FALSE)

```



# Economic Indicators Over Time: CPI, SPY Closing Prices, and Treasury Bond Yields

```{r}
#| echo: false
#| warning: false
#| message: false

library(ggplot2)
library(dplyr)

# Economic Indicators Over Time

## Consumer Price Index (CPI) Over Time
# Line plot for CPI
ggplot(data = monthly_data, aes(x = date, y = CPI)) +
  geom_line(color = "blue") +
  labs(title = "Consumer Price Index (CPI) Over Time", x = "Date", y = "CPI") +
  theme_minimal()

## SPY Monthly Closing Prices Over Time
# Line plot for SPY_CLOSE
ggplot(data = monthly_data, aes(x = date, y = SPY_CLOSE)) +
  geom_line(color = "green") +
  labs(title = "SPY Monthly Closing Prices Over Time", x = "Date", y = "SPY Close") +
  theme_minimal()

## 10-Year Treasury Bond Yields Over Time
# Line plot for 10-Year Bond Yields
ggplot(data = monthly_data, aes(x = date, y = `10_Year_Bond`)) +
  geom_line(color = "red") +
  labs(title = "10-Year Treasury Bond Yields Over Time", x = "Date", y = "10-Year Bond Yield") +
  theme_minimal()

## 2-Year Treasury Bond Yields Over Time
# Line plot for 2-Year Bond Yields
ggplot(data = monthly_data, aes(x = date, y = `2_Year_Bond`)) +
  geom_line(color = "purple") +
  labs(title = "2-Year Treasury Bond Yields Over Time", x = "Date", y = "2-Year Bond Yield") +
  theme_minimal()



```



```{r}
#| echo: false
#| warning: false
#| message: false

library(ggplot2)
library(tidyr)

# Reshape data to long format for faceting
monthly_data_long <- monthly_data %>%
  pivot_longer(
    cols = c(CPI, SPY_CLOSE, `10_Year_Bond`, `2_Year_Bond`),
    names_to = "Variable",
    values_to = "Value"
  )

# Create the plot
ggplot(data = monthly_data_long, aes(x = date, y = Value)) +
  geom_line(aes(color = Variable), show.legend = FALSE) +
  facet_wrap(~ Variable, scales = "free_y", ncol = 1) +
  labs(
    title = "Monthly Trends: CPI, SPY Close, and Bond Yields",
    x = "Date",
    y = "Value"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
  )


```




```{r}
#| echo: false
#| warning: false
#| message: false

library(ggplot2)

# Calculate a scaling factor for secondary axis
scale_factor <- max(monthly_data$CPI, na.rm = TRUE) / max(monthly_data$`10_Year_Bond`, na.rm = TRUE)

# Create the plot
ggplot(data = monthly_data, aes(x = date)) +
  # Line for CPI (primary axis)
  geom_line(aes(y = CPI, color = "CPI")) +
  # Line for SPY_CLOSE (primary axis)
  geom_line(aes(y = SPY_CLOSE, color = "SPY_CLOSE")) +
  # Line for 10-Year Bond Yields (secondary axis)
  geom_line(aes(y = `10_Year_Bond` * scale_factor, color = "10-Year Bond")) +
  # Line for 2-Year Bond Yields (secondary axis)
  geom_line(aes(y = `2_Year_Bond` * scale_factor, color = "2-Year Bond")) +
  # Define the primary Y-axis
  scale_y_continuous(
    name = "CPI / SPY Close",
    sec.axis = sec_axis(~ . / scale_factor, name = "Bond Yields") # Secondary Y-axis
  ) +
  # Add labels and title
  labs(
    title = "Monthly Trends: CPI, SPY Close, and Bond Yields",
    x = "Date",
    color = "Variable"
  ) +
  # Style the plot
  theme_minimal() +
  theme(
    axis.title.y.left = element_text(color = "blue"),  # Primary axis style
    axis.title.y.right = element_text(color = "red"),  # Secondary axis style
    legend.position = "top"
  )



```




```{r}
#| echo: false
#| warning: false
#| message: false

library(ggplot2)

# Filter data to include only from 2019 onward
monthly_data_filtered <- monthly_data %>%
  filter(date >= as.Date("2019-01-01"))

# Calculate scaling factor for secondary axis
scale_factor <- max(monthly_data_filtered$CPI, na.rm = TRUE) / max(monthly_data_filtered$`10_Year_Bond`, na.rm = TRUE)

# Create the plot
ggplot(data = monthly_data_filtered, aes(x = date)) +
  # Line for CPI (primary axis)
  geom_line(aes(y = CPI, color = "CPI")) +
  # Line for SPY_CLOSE (primary axis)
  geom_line(aes(y = SPY_CLOSE, color = "SPY_CLOSE")) +
  # Line for 10-Year Bond Yields (secondary axis)
  geom_line(aes(y = `10_Year_Bond` * scale_factor, color = "10-Year Bond")) +
  # Line for 2-Year Bond Yields (secondary axis)
  geom_line(aes(y = `2_Year_Bond` * scale_factor, color = "2-Year Bond")) +
  # Define the primary Y-axis
  scale_y_continuous(
    name = "CPI / SPY Close",
    sec.axis = sec_axis(~ . / scale_factor, name = "Bond Yields") # Secondary Y-axis
  ) +
  # Add labels and title
  labs(
    title = "Monthly Trends (2019 Onward): CPI, SPY Close, and Bond Yields",
    x = "Date",
    color = "Variable"
  ) +
  # Style the plot
  theme_minimal() +
  theme(
    axis.title.y.left = element_text(color = "blue"),  # Primary axis style
    axis.title.y.right = element_text(color = "red"),  # Secondary axis style
    legend.position = "top"
  )



```


# Log-Scale Trends: CPI, SPY Prices, and Treasury Yields (2019+)

## Importance of Log Plots Log plots highlight percentage changes, clarify exponential growth, and improve comparisons across variables with large value differences, making trends easier to interpret

```{r}
#| echo: false
#| warning: false
#| message: false

library(ggplot2)

# Filter data to include only from 2019 onward (optional)
monthly_data_filtered <- monthly_data %>%
  filter(date >= as.Date("2019-01-01"))

# Plot 1: CPI (log scale)
ggplot(data = monthly_data_filtered, aes(x = date, y = CPI)) +
  geom_line(color = "blue") +
  labs(
    title = "Log-Scale Monthly Trend: CPI",
    x = "Date",
    y = "Log-Scale CPI"
  ) +
  scale_y_log10() +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  )

# Plot 2: SPY_CLOSE (log scale)
ggplot(data = monthly_data_filtered, aes(x = date, y = SPY_CLOSE)) +
  geom_line(color = "orange") +
  labs(
    title = "Log-Scale Monthly Trend: SPY Close",
    x = "Date",
    y = "Log-Scale SPY Close"
  ) +
  scale_y_log10() +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  )

# Plot 3: 10-Year and 2-Year Bond Yields (log scale)
ggplot(data = monthly_data_filtered, aes(x = date)) +
  geom_line(aes(y = `10_Year_Bond`, color = "10-Year Bond")) +
  geom_line(aes(y = `2_Year_Bond`, color = "2-Year Bond")) +
  labs(
    title = "Log-Scale Monthly Trends: 10-Year and 2-Year Bond Yields",
    x = "Date",
    y = "Log-Scale Bond Yields",
    color = "Variable"
  ) +
  scale_y_log10() +
  theme_minimal() +
  theme(
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.y = element_text(size = 12, face = "bold")
  )



```


# Correlation Heatmap

## Explanation of Correlation Heatmap

### Overview
The heatmap visualizes the **correlation coefficients** between four financial variables: **CPI**, **SPY_CLOSE** (S&P 500 closing price), **10-Year Bond**, and **2-Year Bond**. Correlation values range from **-1** to **1**:
- **1**: Perfect positive correlation (variables move in the same direction).
- **-1**: Perfect negative correlation (variables move in opposite directions).
- **0**: No correlation (variables are independent).

### Key Observations
1. **Strong Positive Correlations**:
   - **CPI and SPY_CLOSE**: High correlation (**0.91**) indicates that as CPI (inflation indicator) rises, SPY_CLOSE tends to increase, suggesting equities respond positively to inflation trends.
   - **10-Year Bond and 2-Year Bond**: Strong correlation (**0.84**) reflects the aligned movement of bond yields over time.

2. **Negative Correlations**:
   - **CPI and 10-Year Bond**: Negative correlation (**-0.52**) shows that rising inflation (CPI) often corresponds to declining bond yields, likely due to interest rate adjustments by central banks.
   - **SPY_CLOSE and 10-Year Bond**: Moderate negative correlation (**-0.33**) suggests that equity markets and long-term bond yields are inversely related.

3. **Weak or Neutral Relationships**:
   - **2-Year Bond and SPY_CLOSE**: Low correlation (**0.08**) indicates minimal direct relationship between short-term bond yields and equity markets.
   - **CPI and 2-Year Bond**: Weak negative correlation (**-0.15**) suggests a limited inverse relationship between inflation and short-term bond yields.

### Insights
- **Economic Indicators**: The strong correlation between CPI and SPY_CLOSE highlights the sensitivity of equity markets to inflation.
- **Bond Market Dynamics**: The high correlation between 10-Year and 2-Year Bonds reflects consistent movement across bond maturities, while their inverse relationship with CPI underscores inflation's impact on fixed-income investments.
- **Portfolio Considerations**: Understanding these correlations can help in constructing diversified portfolios and managing risk based on inflation and interest rate trends.

```{r}
#| echo: false
#| warning: false
#| message: false
# Check if reshape2 is installed; if not, install it
if (!requireNamespace("reshape2", quietly = TRUE)) {
  install.packages("reshape2")
}

# Load libraries
library(reshape2)
library(ggplot2)

# Filter the dataset to include only numeric variables and remove missing values
correlation_data <- monthly_data %>%
  select(CPI, SPY_CLOSE, `10_Year_Bond`, `2_Year_Bond`) %>%
  na.omit()

# Compute the correlation matrix
correlation_matrix <- cor(correlation_data)

# Convert the correlation matrix into a long format for ggplot2
correlation_long <- melt(correlation_matrix, varnames = c("Variable1", "Variable2"))

# Create the heatmap
ggplot(correlation_long, aes(x = Variable1, y = Variable2, fill = value)) +
  geom_tile(color = "white") +  # White tile borders for clarity
  geom_text(aes(label = round(value, 2)), color = "black", size = 4) +  # Display correlation values
  scale_fill_gradient2(
    low = "royalblue", mid = "white", high = "orange",  # Royal blue to white to orange
    midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation"
  ) +
  labs(
    title = "Correlation Heatmap",
    x = "Variable", y = "Variable"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 10),
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid = element_blank(),  # Remove grid lines
    panel.background = element_rect(fill = "white")  # Set white background
  )



```




```{r}
#| echo: false
#| warning: false
#| message: false
# TRS Calculation

# Parameters
start_age <- 25
retirement_age <- 65
starting_salary <- 50000
salary_growth_rate <- 0.03
trs_multiplier <- 0.02

# Final Average Salary (FAS)
years_of_service <- retirement_age - start_age
final_salary <- starting_salary * (1 + salary_growth_rate)^years_of_service
final_average_salary <- final_salary * 3 / 3  # Last 3 years' salary

# Annual Benefit
trs_annual_benefit <- final_average_salary * years_of_service * trs_multiplier

# Results for TRS
trs_results <- data.frame(
  Plan = "TRS",
  Wealth_at_Retirement = NA,
  Annual_Retirement_Income = trs_annual_benefit,
  Funds_Left_to_Heirs = NA
)

# Display TRS results
print(trs_results)




```




```{r}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
library(dplyr)

# Load the dataset
file_path <- "C:/Users/alien/OneDrive/Documents/STA9750-2024-FALL/processed_monthly_data.csv"  # Update this to the correct file path
monthly_data <- read.csv(file_path)

# Convert `date` column to Date type
monthly_data$date <- as.Date(monthly_data$date)

# Preview the dataset
head(monthly_data)


```

```{r}
#| echo: false
#| warning: false
#| message: false

# TRS Parameters
start_age <- 25
retirement_age <- 65
starting_salary <- 50000
salary_growth_rate <- 0.03
trs_multiplier <- 0.02

# Calculate Final Average Salary (FAS)
years_of_service <- retirement_age - start_age
final_salary <- starting_salary * (1 + salary_growth_rate)^years_of_service
final_average_salary <- final_salary * 3 / 3  # Average of last 3 years' salary

# Calculate Annual Benefit
trs_annual_benefit <- final_average_salary * years_of_service * trs_multiplier

# Inflation Adjustment (using historical CPI data)
cpi_last_12_months <- tail(monthly_data$CPI, 12)
cpi_diff <- diff(cpi_last_12_months)
cpi_lag <- head(cpi_last_12_months, -1)
annual_inflation <- mean(cpi_diff / cpi_lag, na.rm = TRUE)
inflation_adjustment <- min(max(annual_inflation * 0.5, 0.01), 0.03)  # Capped between 1%-3%

# Adjust TRS Annual Benefit
trs_annual_benefit_adjusted <- trs_annual_benefit * (1 + inflation_adjustment)



```




```{r}
#| echo: false
#| warning: false
#| message: false

# ORP Parameters
orp_employee_rate <- 0.035
orp_employer_rate_initial <- 0.08
orp_employer_rate_later <- 0.10
withdrawal_rate <- 0.04

# Initialize ORP balance
orp_balance <- 0
for (month in 1:nrow(monthly_data)) {
  current_salary <- starting_salary * (1 + salary_growth_rate)^((month - 1) / 12)
  employee_contribution <- current_salary * orp_employee_rate / 12
  employer_rate <- ifelse(month <= 7 * 12, orp_employer_rate_initial, orp_employer_rate_later)
  employer_contribution <- current_salary * employer_rate / 12
  total_contribution <- employee_contribution + employer_contribution
  
  # Monthly return
  month_return <- 0.54 * monthly_data$US_Equities_Return[month] +
                  0.10 * monthly_data$Bonds_Return[month]
  orp_balance <- (orp_balance + total_contribution) * (1 + month_return)
}

# Final ORP Balance at Retirement
final_orp_balance <- tail(orp_balance, 1)



```


```{r}
#| echo: false
#| warning: false
#| message: false

# Calculate Annual Withdrawal and Remaining Balance
annual_withdrawal <- final_orp_balance * withdrawal_rate
remaining_balance <- final_orp_balance - (annual_withdrawal * (85 - 65))  # Withdrawals for 20 years


```

```{r}
#| echo: false
#| warning: false
#| message: false
# Final ORP Balance at Retirement
final_orp_balance <- tail(orp_balance, 1)

# Calculate Annual Withdrawal and Remaining Balance
annual_withdrawal <- final_orp_balance * withdrawal_rate
remaining_balance <- final_orp_balance - (annual_withdrawal * (85 - 65))  # Withdrawals for 20 years

# Combine TRS and ORP Results
results <- data.frame(
  Plan = c("TRS", "ORP"),
  Wealth_at_Retirement = c(NA, final_orp_balance),
  Annual_Retirement_Income = c(trs_annual_benefit_adjusted, annual_withdrawal),
  Funds_Left_to_Heirs = c(NA, remaining_balance)
)

# Display Results
print(results)



```


## Explanation of Wealth Growth Chart

### Overview
- The chart compares the growth of wealth over time under two retirement plans: **Optional Retirement Plan (ORP)** and **Teacher Retirement System (TRS)**.
- Historical data for stock and bond returns is used to simulate the ORP, while TRS wealth is calculated based on a defined benefit formula.

### Key Components
1. **ORP (Optional Retirement Plan)**:
   - Wealth grows through monthly employee and employer contributions, adjusted for historical market returns.
   - Contributions:
     - **Employee rate**: 3.5%.
     - **Employer rate**: 8% for the first 7 years, 10% thereafter.
   - Returns:
     - Weighted portfolio of **54% equities** and **10% bonds** reflects realistic market exposure.

2. **TRS (Teacher Retirement System)**:
   - A defined benefit plan based on:
     - Starting salary.
     - Salary growth rate (3% annually).
     - Multiplier (2%) for years of service.
   - Annual benefit is inflation-adjusted based on historical CPI data, capped between 1%-3%.

### Insights from the Chart
- **ORP Growth**:
  - Wealth fluctuates with market performance, showing higher growth during favorable market conditions.
  - Contributions and compounding returns lead to exponential growth over time.
  
- **TRS Growth**:
  - Wealth increases linearly, reflecting steady payouts starting at retirement age (65).
  - Inflation adjustments ensure TRS payouts retain purchasing power but do not exhibit market-driven volatility.

### Key Takeaways
- **Market Dependency**: ORP wealth is more sensitive to market performance, offering higher growth potential but also greater risk.
- **Stability**: TRS wealth grows steadily, providing predictable income, especially for risk-averse individuals.
- **Comparison**: The chart allows individuals to weigh the trade-offs between potential market-driven growth (ORP) and stability (TRS) when planning for retirement.


```{r}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
library(dplyr)
library(ggplot2)

# Load the dataset
file_path <- "processed_monthly_data.csv"  # Replace with the actual file path
monthly_data <- read.csv(file_path)

# Ensure the `date` column is in Date format
monthly_data$date <- as.Date(monthly_data$date)

# Add derived columns for CPI change and stock/bond returns
monthly_data <- monthly_data %>%
  mutate(
    CPI_Lag = lag(CPI),  # Lagged CPI for consistent length
    CPI_Change = (CPI - CPI_Lag) / CPI_Lag,  # Calculate CPI change
    US_Equities_Lag = lag(SPY_CLOSE),  # Lagged SPY_CLOSE
    US_Equities_Return = (SPY_CLOSE - US_Equities_Lag) / US_Equities_Lag,  # Stock returns
    Bonds_Return = (X10_Year_Bond + X2_Year_Bond) / 2 / 100  # Average bond returns
  ) %>%
  filter(!is.na(CPI_Change), !is.na(US_Equities_Return), !is.na(Bonds_Return))  # Remove incomplete rows

# ORP Parameters
orp_employee_rate <- 0.035
orp_employer_rate_initial <- 0.08
orp_employer_rate_later <- 0.10
starting_salary <- 50000
salary_growth_rate <- 0.03

# Simulate ORP growth using historical data
months <- 1:nrow(monthly_data)
orp_balance_over_time <- numeric(length(months))
current_balance <- 0

for (month in months) {
  current_salary <- starting_salary * (1 + salary_growth_rate)^((month - 1) / 12)
  employee_contribution <- current_salary * orp_employee_rate / 12
  employer_rate <- ifelse(month <= 7 * 12, orp_employer_rate_initial, orp_employer_rate_later)
  employer_contribution <- current_salary * employer_rate / 12
  total_contribution <- employee_contribution + employer_contribution
  
  # Monthly return based on historical data
  monthly_return <- 0.54 * monthly_data$US_Equities_Return[month] +
                    0.10 * monthly_data$Bonds_Return[month]
  current_balance <- (current_balance + total_contribution) * (1 + monthly_return)
  orp_balance_over_time[month] <- current_balance
}

# TRS Parameters
trs_multiplier <- 0.02
retirement_age <- 65
start_age <- 25
years_of_service <- retirement_age - start_age
trs_annual_benefit <- (starting_salary * (1 + salary_growth_rate)^years_of_service) * years_of_service * trs_multiplier

# Inflation Adjustment (using historical CPI data)
cpi_last_12_months <- tail(monthly_data$CPI, 12)
cpi_diff <- diff(cpi_last_12_months)
cpi_lag <- head(cpi_last_12_months, -1)
annual_inflation <- mean(cpi_diff / cpi_lag, na.rm = TRUE)
inflation_adjustment <- min(max(annual_inflation * 0.5, 0.01), 0.03)  # Capped between 1%-3%
trs_annual_benefit_adjusted <- trs_annual_benefit * (1 + inflation_adjustment)

# Create Wealth Data for Visualization
wealth_data <- data.frame(
  Month = rep(months, 2),
  Wealth = c(orp_balance_over_time, trs_annual_benefit_adjusted * (months %/% 12)),
  Plan = rep(c("ORP", "TRS"), each = length(months))
)

# Plot Wealth Growth
ggplot(wealth_data, aes(x = Month, y = Wealth, color = Plan)) +
  geom_line(size = 1.2) +
  labs(
    title = "Wealth Growth Over Time: ORP vs TRS (Using Historical Data)",
    x = "Months",
    y = "Wealth ($)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    text = element_text(size = 12)
  )



```





```{r}
#| echo: false
#| warning: false
#| message: false

# Check and install the `scales` package if not already installed
if (!requireNamespace("scales", quietly = TRUE)) {
  install.packages("scales")
}

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(scales)  # Load the scales package for dollar formatting

# Load the dataset
file_path <- "processed_monthly_data.csv"  # Replace with the correct file path
monthly_data <- read.csv(file_path)

# Convert `date` column to Date format
monthly_data$date <- as.Date(monthly_data$date)

# Add derived columns for CPI change, stock returns, and bond returns
monthly_data <- monthly_data %>%
  mutate(
    CPI_Lag = lag(CPI),  # Lagged CPI for calculation
    CPI_Change = (CPI - CPI_Lag) / CPI_Lag,  # Calculate CPI change
    US_Equities_Lag = lag(SPY_CLOSE),  # Lagged SPY_CLOSE for calculation
    US_Equities_Return = (SPY_CLOSE - US_Equities_Lag) / US_Equities_Lag,  # Stock returns
    Bonds_Return = (X10_Year_Bond + X2_Year_Bond) / 2 / 100  # Average bond returns
  ) %>%
  filter(!is.na(CPI_Change), !is.na(US_Equities_Return), !is.na(Bonds_Return))  # Remove incomplete rows

# ORP Parameters
orp_employee_rate <- 0.035
orp_employer_rate_initial <- 0.08
orp_employer_rate_later <- 0.10
starting_salary <- 50000
salary_growth_rate <- 0.03

# Simulate ORP balance growth
months <- 1:nrow(monthly_data)
orp_balance <- numeric(length(months))
current_balance <- 0

for (month in months) {
  # Calculate current salary with growth
  current_salary <- starting_salary * (1 + salary_growth_rate)^((month - 1) / 12)
  
  # Contributions
  employee_contribution <- current_salary * orp_employee_rate / 12
  employer_rate <- ifelse(month <= 7 * 12, orp_employer_rate_initial, orp_employer_rate_later)
  employer_contribution <- current_salary * employer_rate / 12
  total_contribution <- employee_contribution + employer_contribution
  
  # Monthly returns
  monthly_return <- 0.54 * monthly_data$US_Equities_Return[month] +
                    0.10 * monthly_data$Bonds_Return[month]
  current_balance <- (current_balance + total_contribution) * (1 + monthly_return)
  orp_balance[month] <- current_balance
}

# TRS Parameters
trs_multiplier <- 0.02
retirement_age <- 65
start_age <- 25
years_of_service <- retirement_age - start_age
trs_annual_benefit <- (starting_salary * (1 + salary_growth_rate)^years_of_service) * years_of_service * trs_multiplier

# Inflation adjustment for TRS using historical CPI
cpi_last_12_months <- tail(monthly_data$CPI, 12)
cpi_diff <- diff(cpi_last_12_months)
cpi_lag <- head(cpi_last_12_months, -1)
annual_inflation <- mean(cpi_diff / cpi_lag, na.rm = TRUE)
inflation_adjustment <- min(max(annual_inflation * 0.5, 0.01), 0.03)  # Cap 1%-3%
trs_annual_benefit_adjusted <- trs_annual_benefit * (1 + inflation_adjustment)

# Calculate combined wealth (ORP + TRS)
total_wealth <- orp_balance + trs_annual_benefit_adjusted * (months %/% 12)

# Create combined wealth data for visualization
combined_wealth_data <- data.frame(
  Month = months,
  Total_Wealth = total_wealth
)

# Plot combined wealth with dollar formatting
ggplot(combined_wealth_data, aes(x = Month, y = Total_Wealth)) +
  geom_line(size = 1.2, color = "blue") +
  scale_y_continuous(labels = label_dollar()) +  # Format y-axis as dollars
  labs(
    title = "Total Wealth Growth Over Time: ORP + TRS",
    x = "Months",
    y = "Total Wealth ($)"
  ) +
  theme_minimal() +
  theme(
    text = element_text(size = 12)
  )




```

```{r}
#| echo: false
#| warning: false
#| message: false

# Display assumptions used in the calculations
assumptions <- list(
  "General Assumptions" = list(
    "Starting Salary" = "$50,000",
    "Salary Growth Rate" = "3% annually",
    "Simulation Period" = "Monthly"
  ),
  "ORP Assumptions" = list(
    "Employee Contribution Rate" = "3.5%",
    "Employer Contribution Rate (First 7 Years)" = "8%",
    "Employer Contribution Rate (After 7 Years)" = "10%",
    "Equity Allocation" = "54% US Equities, 10% Bonds",
    "Annual Return (Approximation)" = "5% (varies based on historical data)"
  ),
  "TRS Assumptions" = list(
    "Years of Service" = "40 years (Age 25 to 65)",
    "TRS Multiplier" = "2% per year of service",
    "Final Average Salary (FAS)" = "Computed using last 3 years of salary",
    "Inflation Adjustment" = "Capped between 1% and 3% annually"
  )
)

# Print assumptions in a readable format
print_assumptions <- function(assumptions) {
  cat("Assumptions Used in Calculations:\n")
  for (category in names(assumptions)) {
    cat("\n", category, ":\n", sep = "")
    for (key in names(assumptions[[category]])) {
      cat("  -", key, ":", assumptions[[category]][[key]], "\n")
    }
  }
}

# Call the function to display the assumptions
print_assumptions(assumptions)
```


```{r}
#| echo: false
#| warning: false
#| message: false

# Display assumptions and long-term averages
assumptions <- list(
  "General Assumptions" = list(
    "Starting Salary" = "$50,000",
    "Salary Growth Rate" = "3% annually",
    "Simulation Period" = "Monthly, over 40 years"
  ),
  "ORP Assumptions" = list(
    "Employee Contribution Rate" = "3.5%",
    "Employer Contribution Rate (First 7 Years)" = "8%",
    "Employer Contribution Rate (After 7 Years)" = "10%",
    "Equity Allocation" = "54% US Equities, 10% Bonds",
    "Average Annual Return (Historical)" = paste(round(mean(monthly_data$US_Equities_Return, na.rm = TRUE) * 12 * 100, 2), "%"),
    "Bond Return (Historical)" = paste(round(mean(monthly_data$Bonds_Return, na.rm = TRUE) * 12 * 100, 2), "%")
  ),
  "TRS Assumptions" = list(
    "Years of Service" = "40 years (Age 25 to 65)",
    "TRS Multiplier" = "2% per year of service",
    "Final Average Salary (FAS)" = "Computed using last 3 years of salary",
    "Inflation Adjustment (Historical)" = paste(round(mean(monthly_data$CPI_Change, na.rm = TRUE) * 100, 2), "% annually, capped at 1%-3%")
  )
)

# Function to print assumptions in a readable format
print_assumptions <- function(assumptions) {
  cat("Assumptions and Long-Term Averages Used in the Analysis:\n")
  for (category in names(assumptions)) {
    cat("\n", category, ":\n", sep = "")
    for (key in names(assumptions[[category]])) {
      cat("  -", key, ":", assumptions[[category]][[key]], "\n")
    }
  }
}

# Call the function to display the assumptions
print_assumptions(assumptions)



```
```{r}
#| echo: false
#| warning: false
#| message: false

# Display assumptions and explain how they are derived from the dataset
assumptions <- list(
  "General Assumptions" = list(
    "Starting Salary" = "$50,000",
    "Salary Growth Rate" = "3% annually",
    "Simulation Period" = "Monthly, over 40 years"
  ),
  "ORP Assumptions" = list(
    "Employee Contribution Rate" = "3.5% (fixed)",
    "Employer Contribution Rate (First 7 Years)" = "8% (fixed)",
    "Employer Contribution Rate (After 7 Years)" = "10% (fixed)",
    "Equity Allocation" = "54% US Equities, 10% Bonds",
    "Average Annual Return (Historical)" = paste0(
      "Derived from the `SPY_CLOSE` column in the dataset: ",
      round(mean(monthly_data$US_Equities_Return, na.rm = TRUE) * 12 * 100, 2),
      "%"
    ),
    "Bond Return (Historical)" = paste0(
      "Derived from the `X10_Year_Bond` and `X2_Year_Bond` columns: ",
      round(mean(monthly_data$Bonds_Return, na.rm = TRUE) * 12 * 100, 2),
      "%"
    )
  ),
  "TRS Assumptions" = list(
    "Years of Service" = "40 years (Age 25 to 65)",
    "TRS Multiplier" = "2% per year of service (fixed)",
    "Final Average Salary (FAS)" = "Computed using last 3 years of salary",
    "Inflation Adjustment (Historical)" = paste0(
      "Derived from the `CPI` column in the dataset: ",
      round(mean(monthly_data$CPI_Change, na.rm = TRUE) * 100, 2),
      "% annually (capped at 1%-3%)"
    )
  )
)

# Function to print assumptions with dataset references
print_assumptions <- function(assumptions) {
  cat("Assumptions and Their Derivation from the Dataset:\n")
  for (category in names(assumptions)) {
    cat("\n", category, ":\n", sep = "")
    for (key in names(assumptions[[category]])) {
      cat("  -", key, ":", assumptions[[category]][[key]], "\n")
    }
  }
}

# Call the function to display the assumptions
print_assumptions(assumptions)


```

## Visualize Bootstrap Distributions

### Equity Returns Distribution
- **Description**:  
  - The histogram displays the frequency distribution of mean equity returns across bootstrap samples.
  - Blue bars visually represent the spread of equity return means, highlighting variability.

### Bond Returns Distribution
- **Description**:  
  - The histogram displays the frequency distribution of mean bond returns across bootstrap samples.
  - Green bars illustrate the spread of bond return means, showcasing their variability.

### Insights
- **Variability**:  
  - The analysis reveals the variability of equity and bond returns over multiple resampled datasets.
- **Understanding Stability**:  
  - Visualizing the bootstrap distributions helps assess the spread and stability of return estimates.



```{r}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
library(dplyr)
library(ggplot2)

# Load the dataset
file_path <- "processed_monthly_data.csv"  # Replace with your dataset path
monthly_data <- read.csv(file_path)

# Ensure the `date` column is in Date format
monthly_data$date <- as.Date(monthly_data$date)

# Add derived columns for equity and bond returns
monthly_data <- monthly_data %>%
  mutate(
    US_Equities_Return = (SPY_CLOSE - lag(SPY_CLOSE)) / lag(SPY_CLOSE),  # Stock returns
    Bonds_Return = (X10_Year_Bond + X2_Year_Bond) / 2 / 100  # Average bond returns
  ) %>%
  filter(!is.na(US_Equities_Return), !is.na(Bonds_Return))  # Remove NA rows

# Define the bootstrap parameters
set.seed(123)  # For reproducibility
n_boot <- 500  # Number of bootstrap samples
n <- nrow(monthly_data)  # Sample size

# Bootstrap resampling
bootstrap_results <- data.frame(
  resample_id = integer(),
  mean_equity_return = numeric(),
  mean_bond_return = numeric()
)

for (i in 1:n_boot) {
  # Resample rows with replacement
  boot_sample <- monthly_data %>% slice_sample(n = n, replace = TRUE)
  
  # Compute statistics for this bootstrap sample
  equity_mean <- mean(boot_sample$US_Equities_Return, na.rm = TRUE)
  bond_mean <- mean(boot_sample$Bonds_Return, na.rm = TRUE)
  
  # Store the results
  bootstrap_results <- rbind(bootstrap_results, data.frame(
    resample_id = i,
    mean_equity_return = equity_mean,
    mean_bond_return = bond_mean
  ))
}

# Calculate bootstrap variances
bootstrap_variances <- bootstrap_results %>%
  summarize(
    var_equity_return = var(mean_equity_return),
    var_bond_return = var(mean_bond_return)
  )

# Display results
cat("Bootstrap Results:\n")
cat("Variance of Equity Returns:", bootstrap_variances$var_equity_return, "\n")
cat("Variance of Bond Returns:", bootstrap_variances$var_bond_return, "\n")

# Visualization of Bootstrap Distribution
ggplot(bootstrap_results, aes(x = mean_equity_return)) +
  geom_histogram(bins = 30, fill = "blue", alpha = 0.7) +
  labs(
    title = "Bootstrap Distribution of Mean Equity Returns",
    x = "Mean Equity Return",
    y = "Frequency"
  ) +
  theme_minimal()

ggplot(bootstrap_results, aes(x = mean_bond_return)) +
  geom_histogram(bins = 30, fill = "green", alpha = 0.7) +
  labs(
    title = "Bootstrap Distribution of Mean Bond Returns",
    x = "Mean Bond Return",
    y = "Frequency"
  ) +
  theme_minimal()



```

## Monte Carlo Simulation: Portfolio Growth with Changing Returns

### Overview
- This simulation models portfolio growth over 30 years with an initial investment of $100,000.
- The portfolio allocation is **70% equities** and **30% bonds**.
- Three scenarios are analyzed:
  - **Base Case**: 5% annual equity return, 3% annual bond return.
  - **Higher Returns**: 10% increase in equity and bond returns.
  - **Lower Returns**: 10% decrease in equity and bond returns.

### Assumptions
- **Equity variance**: 6.786352e-06  
- **Bond variance**: 7.180288e-07  
- **Portfolio weights**: 70% equities, 30% bonds  
- Monthly returns are calculated by dividing annual returns by 12.

### Simulation Process
1. **Generate Monthly Returns**: 
   - Simulate equity and bond returns using random normal distributions based on their mean and variance.
2. **Combine Portfolio Returns**: 
   - Calculate total returns weighted by 70% equities and 30% bonds.
3. **Compute Portfolio Growth**: 
   - Compound monthly returns over 360 months (30 years) to simulate portfolio growth.

### Results
- The simulation outputs portfolio growth under three scenarios:
  - **Base Case**: Moderate growth with average market returns.
  - **Higher Returns**: Faster growth reflecting favorable market conditions.
  - **Lower Returns**: Slower growth highlighting unfavorable market conditions.

### Visualization
- The line plot illustrates portfolio value over time:
  - **Base Case**: A steady growth curve.
  - **Higher Returns**: A steeper growth trajectory due to increased returns.
  - **Lower Returns**: A flatter growth curve emphasizing the impact of lower returns.




```{r}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(scales)  # For dollar formatting

# Variances from previous bootstrap analysis
variance_equity_returns <- 6.786352e-06
variance_bond_returns <- 7.180288e-07

# Long-term assumptions for financial returns
mean_equity_return <- 0.05  # Assume 5% annual equity return
mean_bond_return <- 0.03    # Assume 3% annual bond return

# Convert annualized returns to monthly returns
monthly_equity_return <- mean_equity_return / 12
monthly_bond_return <- mean_bond_return / 12

# Monte Carlo simulation settings
set.seed(123)  # For reproducibility
n_months <- 360  # 30 years of monthly returns
initial_investment <- 100000  # Assume $100,000 initial investment
n_simulations <- 3  # Number of simulations

# Simulate portfolio growth for changing return scenarios
simulate_portfolio_growth <- function(equity_mean, bond_mean, equity_var, bond_var, months, initial_value) {
  # Generate simulated monthly returns
  simulated_equity_returns <- rnorm(months, mean = equity_mean, sd = sqrt(equity_var))
  simulated_bond_returns <- rnorm(months, mean = bond_mean, sd = sqrt(bond_var))
  
  # Combine returns into a portfolio (e.g., 70% equity, 30% bond)
  portfolio_weights <- c(0.7, 0.3)
  simulated_portfolio_returns <- portfolio_weights[1] * simulated_equity_returns +
                                 portfolio_weights[2] * simulated_bond_returns
  
  # Compute cumulative portfolio growth
  cumprod(1 + simulated_portfolio_returns) * initial_value
}

# Define different return scenarios
scenarios <- data.frame(
  Simulation = c("Base Case", "Higher Returns", "Lower Returns"),
  Equity_Mean = c(monthly_equity_return, monthly_equity_return * 1.1, monthly_equity_return * 0.9),
  Bond_Mean = c(monthly_bond_return, monthly_bond_return * 1.1, monthly_bond_return * 0.9),
  Equity_Variance = c(variance_equity_returns, variance_equity_returns * 1.1, variance_equity_returns * 0.9),
  Bond_Variance = c(variance_bond_returns, variance_bond_returns * 1.1, variance_bond_returns * 0.9)
)

# Run simulations
portfolio_growth_list <- lapply(1:n_simulations, function(i) {
  simulate_portfolio_growth(
    equity_mean = scenarios$Equity_Mean[i],
    bond_mean = scenarios$Bond_Mean[i],
    equity_var = scenarios$Equity_Variance[i],
    bond_var = scenarios$Bond_Variance[i],
    months = n_months,
    initial_value = initial_investment
  )
})

# Combine results into a data frame for plotting
portfolio_data <- data.frame(
  Month = rep(1:n_months, n_simulations),
  Portfolio_Value = unlist(portfolio_growth_list),
  Simulation = rep(scenarios$Simulation, each = n_months)
)

# Plot the portfolio growth for all scenarios
ggplot(portfolio_data, aes(x = Month, y = Portfolio_Value, color = Simulation)) +
  geom_line(size = 1.2) +
  scale_y_continuous(labels = label_dollar()) +  # Format y-axis as dollars
  labs(
    title = "Monte Carlo Simulations: Portfolio Growth with Changing Returns",
    x = "Months",
    y = "Portfolio Value ($)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    text = element_text(size = 12)
  )



```
# Monte Carlo Simulation of Portfolio Returns
## Exploring Base Case, Higher Returns, and Lower Returns Scenarios


### This Monte Carlo simulation examines portfolio returns over 30 years under three scenarios: Base Case, Higher Returns, and Lower Returns. It models a 70% equity and 30% bond portfolio using historical assumptions and variance estimates, providing insights into expected performance and risk levels.

## Key Statistics:
### 1. Base Case: Mean monthly return of 0.37%, variance of 3.17 × 10⁻⁶, standard deviation of 0.18%.
### 2. Higher Returns: Mean monthly return of 0.42%, variance of 3.90 × 10⁻⁶, standard deviation of 0.20%.
### 3. Lower Returns: Mean monthly return of 0.34%, variance of 3.14 × 10⁻⁶, standard deviation of 0.18%.

## Insights:
### The Base Case shows stable growth with moderate risk, while the Higher Returns scenario highlights increased opportunities at the cost of higher volatility. The Lower Returns scenario emphasizes the importance of conservative expectations in uncertain environments. Density plots reveal the probability distribution of monthly returns across scenarios, providing a clear view of potential outcomes.

## Simulation Results

### Base Case
- **Mean monthly return**: 0.37%  
- **Variance**: 0.00000317  
- **Standard deviation**: 0.178%  
- Represents stable growth with moderate risk.

### Higher Returns
- **Mean monthly return**: 0.42%  
- **Variance**: 0.00000390  
- **Standard deviation**: 0.197%  
- Indicates higher potential returns with increased volatility.

### Lower Returns
- **Mean monthly return**: 0.34%  
- **Variance**: 0.00000314  
- **Standard deviation**: 0.177%  
- Emphasizes realistic expectations and lower risk.

### Insight
- Highlights the trade-off between risk and return across scenarios.

## Portfolio Return Simulation: Mean, Variance, and Standard Deviation Across Scenarios

```{r}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(scales)  # For dollar formatting

# Variances from previous bootstrap analysis
variance_equity_returns <- 6.786352e-06
variance_bond_returns <- 7.180288e-07

# Long-term assumptions for financial returns
mean_equity_return <- 0.05  # Assume 5% annual equity return
mean_bond_return <- 0.03    # Assume 3% annual bond return

# Convert annualized returns to monthly returns
monthly_equity_return <- mean_equity_return / 12
monthly_bond_return <- mean_bond_return / 12

# Monte Carlo simulation settings
set.seed(123)  # For reproducibility
n_months <- 360  # 30 years of monthly returns
n_simulations <- 1000  # Number of simulations for distributions

# Simulate portfolio returns for distribution visualization
simulate_portfolio_returns <- function(equity_mean, bond_mean, equity_var, bond_var, months) {
  # Generate simulated monthly returns
  simulated_equity_returns <- rnorm(months, mean = equity_mean, sd = sqrt(equity_var))
  simulated_bond_returns <- rnorm(months, mean = bond_mean, sd = sqrt(bond_var))
  
  # Combine returns into a portfolio (e.g., 70% equity, 30% bond)
  portfolio_weights <- c(0.7, 0.3)
  simulated_portfolio_returns <- portfolio_weights[1] * simulated_equity_returns +
                                 portfolio_weights[2] * simulated_bond_returns
  
  simulated_portfolio_returns
}

# Define different return scenarios
scenarios <- data.frame(
  Simulation = c("Base Case", "Higher Returns", "Lower Returns"),
  Equity_Mean = c(monthly_equity_return, monthly_equity_return * 1.1, monthly_equity_return * 0.9),
  Bond_Mean = c(monthly_bond_return, monthly_bond_return * 1.1, monthly_bond_return * 0.9),
  Equity_Variance = c(variance_equity_returns, variance_equity_returns * 1.1, variance_equity_returns * 0.9),
  Bond_Variance = c(variance_bond_returns, variance_bond_returns * 1.1, variance_bond_returns * 0.9)
)

# Generate return distributions for each scenario
return_distributions <- lapply(1:nrow(scenarios), function(i) {
  simulate_portfolio_returns(
    equity_mean = scenarios$Equity_Mean[i],
    bond_mean = scenarios$Bond_Mean[i],
    equity_var = scenarios$Equity_Variance[i],
    bond_var = scenarios$Bond_Variance[i],
    months = n_months
  )
})

# Combine return distributions into a single data frame
distribution_data <- data.frame(
  Returns = unlist(return_distributions),
  Simulation = rep(scenarios$Simulation, each = n_months)
)

# Calculate statistics for each scenario
statistics <- distribution_data %>%
  group_by(Simulation) %>%
  summarize(
    Mean = mean(Returns),
    Variance = var(Returns),
    Std_Dev = sd(Returns)
  )

print(statistics)

# Plot the distribution of portfolio returns
ggplot(distribution_data, aes(x = Returns, fill = Simulation)) +
  geom_density(alpha = 0.6) +
  scale_x_continuous(labels = scales::percent_format(accuracy = 0.1)) +  # Format x-axis as percentages
  labs(
    title = "Distribution of Simulated Monthly Portfolio Returns",
    x = "Monthly Portfolio Returns (%)",
    y = "Density",
    fill = "Simulation"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    text = element_text(size = 12)
  )



```


