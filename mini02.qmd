---
title: "Mini-Project #02: The Business of Show Business"
format:
  html:
    code-link: true
    code-fold: true           # Enables code folding
    code-summary: "Show Code" # Custom text for toggling
    code-fold-default: hide   # Code hidden by default
---



```{r}
# to clear variables: rm(list = ls())

#setwd("C:/Users/alien/OneDrive/Documents/STA9750-2024-FALL")


# Install and load necessary packages
required_packages <- c("stringr", "ggplot2", "readr", "dplyr", "scales")

# Install missing packages
for (pkg in required_packages) {
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg, dependencies = TRUE)
    library(pkg, character.only = TRUE)
  }
}

# Now that packages are installed, you can start your analysis

#install.packages("stringr", dependencies = TRUE)

#library(stringr)
#tr_count("test", "t")  # Simple test

# Install and load necessary packages
#packages <- c("stringr", "dplyr", "ggplot2", "scales")

# Loop through each package and install if missing
#for (pkg in packages) {
#  if (!require(pkg, character.only = TRUE)) {
#    install.packages(pkg, dependencies = TRUE)
#    library(pkg, character.only = TRUE)
#  }
#}
```

```{r}

library(ggplot2)
library(dplyr)



# Install and load ggplot2 package if not already installed
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
library(ggplot2)

# Example with built-in dataset 'mtcars'
#data <- mtcars
#plot <- ggplot2::ggplot(data, ggplot2::aes(x = wt, y = mpg)) +
#        ggplot2::geom_point()

#plot


# Check if the stringr package is installed, if not, install it
if (!require(stringr)) {
  install.packages("stringr")
  library(stringr)
} else {
  library(stringr)
}
#install.packages("tidyr")
library(tidyr)

# Example usage
#result <- stringr::str_count("The quick brown fox", "o")
```

## Mini-Project #02

### Data

For this project, we will use data from the Internet Movie Database (IMDb). Specifically, we will use the tables from [the IMDb
non-commercial release](https://datasets.imdbws.com/). These files
are made freely available by IMDb for non-commercial use. 

The following code will automatically download and load these files
into `R`: 

```{r}
# Reset everything
# rm(list = ls())



#| label: 'imdb_name_basics'
#| message: false 
#| warning: false
#| cache: true
get_imdb_file <- function(fname){
    BASE_URL <- "https://datasets.imdbws.com/"
    fname_ext <- paste0(fname, ".tsv.gz")
    if(!file.exists(fname_ext)){
        FILE_URL <- paste0(BASE_URL, fname_ext)
        download.file(FILE_URL, 
                      destfile = fname_ext)
    }
    as.data.frame(readr::read_tsv(fname_ext, lazy=FALSE))
}

NAME_BASICS      <- get_imdb_file("name.basics")
```

```{r}
#| label: 'imdb_title_basics'
#| message: false 
#| warning: false
#| cache: true
TITLE_BASICS     <- get_imdb_file("title.basics")
```

```{r}
#| label: 'imdb_title_episode'
#| message: false 
#| warning: false
#| cache: true
TITLE_EPISODES   <- get_imdb_file("title.episode")
```

```{r}
#| label: 'imdb_title_ratings'
#| message: false 
#| warning: false
#| cache: true
TITLE_RATINGS    <- get_imdb_file("title.ratings")
```

```{r}
#| label: 'imdb_title_crew'
#| message: false 
#| warning: false
#| cache: true
TITLE_CREW       <- get_imdb_file("title.crew")
```

```{r}
#| label: 'imdb_title_principals'
#| eval: false
#| message: false 
#| warning: false
#| cache: false
TITLE_PRINCIPALS <- get_imdb_file("title.principals")
``` 

Note that these are **large** files and it will take some time for
them to download the first time. Because these files are so large,
it will also take a little while to read them. If you want to speed
up this stage, you can
[cache](https://quarto.org/docs/computations/caching.html#knitr-cache) 
the code chunk that reads the files. This will 'save' the result of the chunk
and only require it to be re-executed when it is changed. 

### Data Sub-Sampling

This data is large enough that we're going to need to immediately 
start down-selecting to get to a data set that we can analyze fluidly. For
our `NAME_BASICS` table, we'll restrict our attention to people with at 
least two "known for" credits.[^1]

```{r}
#| label: 'name_basics_filter'
#| cache: true
NAME_BASICS <- NAME_BASICS |> 
    filter(str_count(knownForTitles, ",") > 1)
```

IMDb has a _long_ tail of obscure movies: 

```{r}
#| label: 'title_ratings_tail'
TITLE_RATINGS |>
    ggplot(aes(x=numVotes)) + 
    geom_histogram(bins=30) +
    xlab("Number of IMDB Ratings") + 
    ylab("Number of Titles") + 
    ggtitle("Majority of IMDB Titles Have Less than 100 Ratings") + 
    theme_bw() + 
    scale_x_log10(label=scales::comma) + 

    scale_y_continuous(label=scales::comma)
```

To keep our computers from working too hard, let's throw out any title
with less than 100 ratings. It's not too hard to see that this drops
about 75% of the entire data set: 

```{r}
#| label: 'title_ratings_quantile'
TITLE_RATINGS |>
    pull(numVotes) |>
    quantile()
```

Applying this drop, we significantly reduce the size of our data set:

```{r}
#| label: 'title_ratings_filter'
#| cache: true
TITLE_RATINGS <- TITLE_RATINGS |>
    filter(numVotes >= 100)
```

We want to perform the same filtering on our other `TITLE_*` tables.
This is a rare use for the [`semi_join`](https://dplyr.tidyverse.org/reference/filter-joins.html).
Recall that a `semi_join` returns only values which have a match,but
doesn't actually add columns. 

```{r}
#| cache: true
#| label: 'title_other_filter'
#| message: false
TITLE_BASICS <- TITLE_BASICS |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_CREW <- TITLE_CREW |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_EPISODES_1 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))
TITLE_EPISODES_2 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(parentTconst == tconst))

TITLE_EPISODES <- bind_rows(TITLE_EPISODES_1,
                            TITLE_EPISODES_2) |>
    distinct()

TITLE_PRINCIPALS <- TITLE_PRINCIPALS |>
    semi_join(TITLE_RATINGS, join_by(tconst == tconst))


rm(TITLE_EPISODES_1)
rm(TITLE_EPISODES_2)
```

At this point, we've filtered down our data _significantly_ and are ready
to begin analysis in earnest. Note that our sub-sampling may induce some
'dangling' references: some of the people dropped from the `NAME_BASICS`
table may only appear in one famous movie, and we've likely lost their
info. 

::: {.callout-warning}
#### Processing Large Data

Even with this processing, this a non-trivial amount of data, requiring
approximately 2 GB of memory. If your computer is significantly
struggling to perform this pre-processing, the instructor may be able to
provide smaller data files upon request. (Even on my quite modern laptop,
the initial processing phase takes a few minutes: by 'significant struggling', I'm referring to processing taking upwards of half an hour
or exhausting all available memory.) Please contact the instructor
and TA through the course discussion board to discuss this possibility.

Processing large data sets is a skill, however, so we're starting with
the large data set to help you practice it.
:::

::: {.callout-important title="Pre-Processed Data" collapse=true}
Exports of the pre-processed data can be found on [the course GitHub
repo](https://github.com/michaelweylandt/STA9750/tree/main/miniprojects/mini02_preprocessed/).
If your computer is struggling to handle the full data set, you may
choose to use these instead. The `readr::read_csv` files handles zip
compression transparently, but you will need to modify `get_imdb_file` above
to: 

1) Point to my GitHub instead of the IMDB archive
2) Use `.csv.zip` files instead of `.tsv.gz`

Note also that, to get the compressed files small enough to store on GitHub,
I had to apply more filtering than the code above uses. Make sure to note
if you are using this extra-filtered extract so that a reader knows why
you might be getting different answers.
:::

### Initial Exploration

At this point, let's start examining our data more closely. Use the
`glimpse` function to examine each table, taking care to note the _type_
or _mode_ of each column. For this data set, most columns appear to be
read in as _character_ (string) vectors, even when they should be
numeric. This can occur when "null" values are represented in some
non-standard way. For instance, in these files, we see that missing
values are represented as `\\N`. `R` does not know that these are `NA`
values and so retains them as strings.[^2]

To fix this, we need to use: 

1. the `mutate` command, since we're changing the type of a column
2. the `as.numeric` command to change the type of the column.

We can clean the `NAMES_BASIC` command as follows: 

```{r, warning=FALSE}
NAME_BASICS <- NAME_BASICS |>
    mutate(birthYear = as.numeric(birthYear),
           deathYear = as.numeric(deathYear))
```

::: {.callout-tip}
#### Task 1: Column Type Correction

Correct the column types of the `TITLE` tables using a combination
of `mutate` and the coercion functions `as.numeric` and `as.logical`.
:::

Another non-tidy aspect of this data is that it combines multiple pieces
of information in a single cell separated by commas. We already saw a bit
of this in the `NAME_BASICS` table, where both the `primaryProfession` and
`knownForTitles` columns combine multiple values. 

```{r}
glimpse(NAME_BASICS)
```

We can use the `separate_longer_delim` function to break these into multiple
rows: for example

```{r}
#| label: 'seaprate_longer_delim_example'
#| cache: true
NAME_BASICS |> separate_longer_delim(knownForTitles, ",") |> slice_head(n=10)
```

To preserve flexibility, let's not fully separate `NAME_BASICS` just yet, but
you will need to use `separate_longer_delim` to answer various questions. 

Using your knowledge of `dplyr` functionality, answer the following questions







::: {.callout-tip}
#### Task 2: Instructor-Provided Questions


1. How many movies are in our data set? How many TV series? How many TV episodes?

```{r}


# Filter and count the number of movies, TV series, and TV episodes
movies_series_episodes_counts <- filter(count(TITLE_BASICS, titleType), 
                                        titleType == "movie" | titleType == "tvSeries" | titleType == "tvEpisode")

# Display the result in a formatted sentence
cat("There are a total of", 
    movies_series_episodes_counts[movies_series_episodes_counts$titleType == "movie", "n"], "movies,",
    movies_series_episodes_counts[movies_series_episodes_counts$titleType == "tvSeries", "n"], "TV series, and",
    movies_series_episodes_counts[movies_series_episodes_counts$titleType == "tvEpisode", "n"], "TV episodes in our data set.")
```


2. Who is the oldest living person in our data set? 

```{r}

# Filter for the oldest living person (who has no death year) and find the minimum birth year
oldest_living_person <- NAME_BASICS |>
  filter(is.na(deathYear)) |>
  slice_min(birthYear)

# Display the result in a formatted sentence
cat("The oldest living person in the data set was born in", 
    oldest_living_person$birthYear, "and their name is", 
    oldest_living_person$primaryName, ".")
```


3. There is one TV Episode in this data set with a perfect 10/10 rating and 200,000 IMDb ratings. What is it? What series does it belong to?

```{r}
perfect_episode <- TITLE_RATINGS |>
  filter(averageRating == 10, numVotes >= 200000) |>  # At least 200,000 votes
  inner_join(TITLE_BASICS, by = "tconst") |>  # Join to get title information
  inner_join(TITLE_EPISODES, by = "tconst") |>  # Episode information
  select(tconst, primaryTitle, originalTitle, titleType, numVotes) |>  # Include identifier
  slice_head(n = 1)  # Select the first episode that meets the criteria

# Display the result in a formatted sentence
cat("The episode with a perfect rating of 10/10 and more than 200,000 votes is",
    perfect_episode$primaryTitle, "with", perfect_episode$numVotes, "votes. The identifier (tconst) is", perfect_episode$tconst, ".")

```

```{r}

# Set a CRAN mirror before installing any packages
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Install magick if necessary
if (!require("magick")) {
  install.packages("magick")
}

# Load libraries
library(dplyr)
library(magick)

# Your existing code to find the perfect episode
perfect_episode <- TITLE_RATINGS |>
  filter(averageRating == 10, numVotes >= 200000) |>  # At least 200,000 votes
  inner_join(TITLE_BASICS, by = "tconst") |>  # Join to get title information
  inner_join(TITLE_EPISODES, by = "tconst") |>  # Episode information
  select(tconst, primaryTitle, originalTitle, titleType, numVotes) |>  # Include identifier
  slice_head(n = 1)  # Select the first episode that meets the criteria

# Display the result in a formatted sentence
cat("The episode with a perfect rating of 10/10 and more than 200,000 votes is",
    perfect_episode$primaryTitle, "with", perfect_episode$numVotes, "votes. The identifier (tconst) is", perfect_episode$tconst, ".")

# Load the image from your local path
img_path <- "C:/Users/alien/OneDrive/Documents/STA9750-2024-FALL/Image Breaking Bad.jpg"  # Path to your local image
img <- image_read(img_path)

# Display the image
print(img)

# Optionally, you can annotate it with text
#image_annotate(img, "Breaking Bad Scene", size = 30, color = "white", location = "+20+20") |> print()



```




4. What four projects is the actor Mark Hamill most known for? 

```{r}


# Get the four projects Mark Hamill is most known for
mark_hamill_projects <- NAME_BASICS |>
  filter(primaryName == "Mark Hamill") |>
  separate_rows(knownForTitles, sep = ",") |>
  inner_join(TITLE_BASICS, by = c("knownForTitles" = "tconst")) |>
  slice(1:4)  # Limit to the first 4 projects

# Display the result in a formatted sentence
cat("Mark Hamill is most known for these four projects:\n",
    paste(mark_hamill_projects$primaryTitle, collapse = ", "), ".")

```



5. What TV series, with more than 12 episodes, has the highest _average_
rating? 

Find the highest average rating among these series

```{r}
# Count episodes per series and filter for series with more than 12 episodes
episode_counts <- TITLE_EPISODES |>
  count(parentTconst) |> 
  filter(n > 12)

# Find the highest average rating among these series
best_series <- TITLE_RATINGS |> 
  inner_join(episode_counts, by = c("tconst" = "parentTconst")) |> 
  arrange(desc(averageRating)) |> 
  inner_join(TITLE_BASICS, by = "tconst") |> 
  slice(1) |> 
  select(primaryTitle, averageRating)

# Display the result in a formatted sentence
cat("The TV series with the highest average rating is", best_series$primaryTitle, 
    "with an average rating of", best_series$averageRating, ".")
```


6. The TV series *Happy Days* (1974-1984) gives us the common idiom ["jump the
   shark"](https://en.wikipedia.org/wiki/Jumping_the_shark). The phrase comes
   from a controversial fifth season episode (aired in 1977) in which a lead
   character literally jumped over a shark on water skis. Idiomatically, it
   is used to refer to the moment when a once-great show becomes ridiculous and
   rapidly looses quality. 
   
   Is it true that episodes from later seasons of *Happy Days* have lower
   average ratings than the early seasons?
 
```{r}

# Step 1: Find the IMDb ID for Happy Days
happy_days <- TITLE_BASICS |>
  filter(primaryTitle == "Happy Days" & titleType == "tvSeries")
happy_days_id <- happy_days$tconst[1]  # Select the first IMDb ID

# Step 2: Get all episodes of Happy Days and their ratings
happy_days_episodes <- TITLE_EPISODES |>
  filter(parentTconst == happy_days_id) |>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  mutate(seasonNumber = as.numeric(seasonNumber)) |>  # Convert seasonNumber to numeric
  select(seasonNumber, averageRating)

# Step 3: Calculate average rating by season, sorted by seasonNumber
average_ratings_by_season <- happy_days_episodes |>
  group_by(seasonNumber) |>
  summarize(avg_rating = mean(averageRating, na.rm = TRUE)) |>
  arrange(seasonNumber)

# Output: Print the IMDb ID and the average ratings by season
cat("The IMDb ID for 'Happy Days' is:", happy_days_id, "\n\n")
cat("Average ratings by season:\n")
print(average_ratings_by_season)
```
   

*Hint:* It may be useful to create a "map" of which columns map to which tables
before attempting these questions. While these can be [quite
formal](https://duckduckgo.com/?q=sql+schema+map&iax=images&ia=images), even 
some basic sketches on a scratch piece of paper are often quite clarifying.
:::

### Quantifying Success

Our goal is to proposal successful new movies. To do so, we need
a way of measuring the success of a movie given only IMDb ratings.[^3] While
there's no "magic number" for success, it is logical to assume that a
successful project will have both a high average IMDb rating, indicating
quality, and a large number of ratings, indicating broad awareness in the
public. 

::: {.callout-tip}
#### Task 3: Custom Success Metric

Design a 'success' measure for IMDb entries, reflecting both quality and
broad popular awareness. Implement your success metric using a `mutate`
operator to add a new column to the `TITLE_RATINGS` table. 

Validate your success metric as follows: 

1. Choose the top 5-10 movies on your metric and confirm that they were
   indeed box office successes.
   
```{r}
# Step 1: Calculate the success metric and get the top 10 movies
top_movies <- TITLE_RATINGS |>
  mutate(success = averageRating * log(numVotes)) |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "movie") |>
  top_n(10, success) |>
  select(primaryTitle, success)

# Step 2: Display the top 10 movies in a simple format
cat("Top 10 movies based on success metric:\n")
cat(top_movies$primaryTitle, sep = "\n")

```

2. Choose 3-5 movies with large numbers of IMDb votes that score poorly
   on your success metric and confirm that they are indeed of low quality.
   
```{r}

# Step 1: Filter movies with votes and calculate the success metric
joined_data <- TITLE_RATINGS |>
  filter(numVotes > 0) |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "movie") |>
  mutate(success = averageRating * log(numVotes))

# Step 2: Select the bottom 5 movies with high vote counts and low success
low_quality_movies <- joined_data |>
  filter(numVotes > 100000) |>
  arrange(success) |>           # Sort by the success metric (ascending)
  slice_head(n = 5) |>
  select(primaryTitle, numVotes, averageRating, success)

# Step 3: Display the result
cat("Bottom 5 movies by success with more than 100,000 votes:\n")
for (i in 1:nrow(low_quality_movies)) {
  cat(i, ". ", low_quality_movies$primaryTitle[i], 
      " | Votes: ", low_quality_movies$numVotes[i], 
      " | Rating: ", low_quality_movies$averageRating[i], 
      " | Success: ", round(low_quality_movies$success[i], 2), "\n", sep = "")
}
```   
   
3. Choose a prestige actor or director and confirm that they have many projects
   with high scores on your success metric.

```{r}


# Step 1: Get Milla Jovovich's ID
milla <- NAME_BASICS |>
  filter(primaryName == "Milla Jovovich")

# Step 2: Get all titles associated with Milla Jovovich (her nconst)
milla_titles <- TITLE_PRINCIPALS |>
  filter(nconst == milla$nconst) |>
  select(tconst)

# Step 3: Join Milla's titles with movie ratings and info, and calculate success
milla_movies <- milla_titles |>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "movie") |>
  mutate(success = averageRating * log(numVotes)) |>
  select(primaryTitle, averageRating, numVotes, success) |>
  arrange(desc(success))  # Sort by success

# Step 4: Show the top 5 successful movies with numVotes and averageRating
top_milla_movies <- milla_movies |> slice_head(n = 5)

# Step 5: Display the result
cat("Top 5 movies starring Milla Jovovich based on success metric:\n")
for (i in 1:nrow(top_milla_movies)) {
  cat(i, ". ", top_milla_movies$primaryTitle[i], 
      " | Votes: ", top_milla_movies$numVotes[i], 
      " | Rating: ", top_milla_movies$averageRating[i], 
      " | Success: ", round(top_milla_movies$success[i], 2), "\n", sep = "")
}


```

4. Perform at least one other form of 'spot check' validation. 

```{r}

# Step 1: Load necessary libraries
install.packages("dplyr")
library(dplyr)

# Step 2: Retrieve all Resident Evil movies from the database, excluding films with less than 200 votes
resident_evil_movies <- TITLE_BASICS |>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  filter(grepl("Resident Evil", primaryTitle, ignore.case = TRUE), numVotes >= 200) |>  # Search for "Resident Evil" and filter votes
  select(primaryTitle, averageRating, numVotes)

# Step 3: Perform a spot check for Milla Jovovich's Resident Evil movies, excluding films with less than 200 votes
milla_movies_spot_check <- TITLE_PRINCIPALS |>
  filter(nconst == "nm0000170") |>  # Milla Jovovich's nconst
  inner_join(TITLE_BASICS, by = "tconst") |> 
  inner_join(TITLE_RATINGS, by = "tconst") |>
  filter(grepl("Resident Evil", primaryTitle, ignore.case = TRUE), numVotes >= 200) |>  # Filter votes >= 200
  select(primaryTitle, averageRating, numVotes)

# Step 4: Display the result of the spot check for Resident Evil movies
cat("Spot check for Milla Jovovich's Resident Evil movies:\n")
apply(milla_movies_spot_check, 1, function(row) {
  cat(row["primaryTitle"], "| Rating:", row["averageRating"], "| Votes:", row["numVotes"], "\n")
})

# Extra Check: Overall Average Rating Comparison
# Step 5: Calculate Milla Jovovich's average rating across all movies
milla_movies_all <- TITLE_PRINCIPALS |>
  filter(nconst == "nm0000170") |>  # Milla Jovovich's nconst
  inner_join(TITLE_BASICS, by = "tconst") |> 
  inner_join(TITLE_RATINGS, by = "tconst") |>
  summarise(overall_avg_rating = mean(averageRating, na.rm = TRUE))

# Step 6: Compare the spot-checked movies' average rating to her overall average
spot_check_avg_rating <- mean(milla_movies_spot_check$averageRating, na.rm = TRUE)

# Step 7: Display final comparison with extra audience details
cat("\nSpot Check Average Rating for Resident Evil movies:", round(spot_check_avg_rating, 2), 
    "\nOverall Average Rating for Milla Jovovich movies:", round(milla_movies_all$overall_avg_rating, 2), "\n")

# Additional explanation
cat("\nHuge Audience: These films have hundreds of thousands of votes, showing they are fan favorites, especially the first Resident Evil with almost 300,000 votes.\n",
    "Strong Appeal: Milla led the series for six movies over 14 years, proving her ability to keep audiences interested.\n",
    "Action Icon: She made Alice a well-loved character in the action-horror genre, turning the Resident Evil series into a lasting success.\n")

```



Spot Check Validation

Task: Perform at least one other form of ‘spot check’ validation.

To further validate Milla Jovovich’s impact in action films, here’s a spot check of her **Resident Evil** movies, showcasing how these popular films performed:

- **Resident Evil** | Rating: 6.6 | Votes: 293,614 
- **Resident Evil: Apocalypse** | Rating: 6.1 | Votes: 212,646 
- **Resident Evil: Extinction** | Rating: 6.2 | Votes: 207,893 
- **Resident Evil: Afterlife** | Rating: 5.8 | Votes: 181,137 
- **Resident Evil: Retribution** | Rating: 5.3 | Votes: 152,062 
- **Resident Evil: The Final Chapter** | Rating: 5.5 | Votes: 102,720

The **Resident Evil** series showcases Milla’s consistent presence in high-action roles, with a strong fan base despite varying ratings. This confirms her staying power in the genre.


5. Come up with a numerical threshold for a project to be a 'success'; that is,
   determine a value $v$ such that movies above $v$ are all "solid" or better.

```{r}
# Step 1: Define a numerical threshold for success
threshold_rating <- 7.5  # Movies with ratings 7.5 and above
threshold_votes <- 100000  # Movies with at least 100,000 votes

# Step 2: Join with TITLE_BASICS and filter for highly rated movies based on thresholds
solid_movies <- TITLE_RATINGS |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(averageRating >= threshold_rating, numVotes >= threshold_votes) |>  
  select(primaryTitle, averageRating, numVotes) |>
  slice_head(n = 10)  # Get the top 10 movies

# Step 3: Display the top solid movies
cat("Top 10 solid movies (IMDb rating >= ", threshold_rating, " and votes >= ", threshold_votes, "):\n", sep = "")
for (i in 1:nrow(solid_movies)) {
  cat(i, ". ", solid_movies$primaryTitle[i], 
      " | Rating: ", solid_movies$averageRating[i], 
      " | Votes: ", solid_movies$numVotes[i], "\n", sep = "")
}

```




```{r}
# Check if the dataset exists and show the structure of the dataset

```






:::

You will use your success metric and threshold to complete the rest of this
Mini-Project. You may, if you wish, restrict your attention to movies for the
remainder of your analysis, though a good development executive should also
consider making TV series. 

### Examining Success by Genre and Decade

Now that you have a working proxy for success, it's time to look at trends in
success over time. Answer the following questions. Your responses should
include at least 2 graphics.

::: {.callout-tip}
#### Task 4: Trends in Success Over Time
Using questions like the following, identify a good "genre" for your next 
film. You do not need to answer these questions precisely, but these are
may help guide your thinking. 

1. What was the genre with the most "successes" in each decade? 

```{r}

# Normalize by the number of movies in each genre
most_successes_in_each_decade <- TITLE_RATINGS |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "movie", as.numeric(startYear) >= 1900) |>
  mutate(decade = 10 * (as.numeric(startYear) %/% 10)) |>
  separate_rows(genres, sep = ",") |>
  group_by(decade, genres) |>
  summarize(total_votes = sum(numVotes), movie_count = n(), .groups = 'drop') |>
  mutate(votes_per_movie = total_votes / movie_count) |>  # Normalize by number of movies
  slice_max(votes_per_movie, by = decade, n = 1)

# Display the results
print(most_successes_in_each_decade)



```





```{r}
# Load necessary libraries
library(ggplot2)

# Plot the results: Votes per movie by genre and decade
ggplot(most_successes_in_each_decade, aes(x = factor(decade), y = votes_per_movie, fill = genres)) +
  geom_col(show.legend = FALSE) +  # Use geom_col to create a bar plot
  geom_text(aes(label = genres), vjust = -0.5, size = 3.5) +  # Add genre labels on top of bars
  labs(
    title = "Top Genre by Decade (Normalized by Votes per Movie)",
    x = "Decade",
    y = "Votes per Movie"
  ) +
  theme_minimal(base_size = 14) +  # Use a clean theme
  scale_y_continuous(labels = scales::comma) +  # Format y-axis for better readability
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better visibility
```


## Genre with the Most "Successes" in Each Decade

When looking at the number of votes per movie, the most successful genre has changed over the decades. This shows how people's tastes in movies have changed over time:

- In the **1920s**, **Sci-Fi** was the most popular genre.
- In the **1930s** and **1940s**, **Animation** was the top genre, with many successful movies during these years.
- By the **1980s** and **1990s**, **Adventure** movies became the favorite, continuing to be the most successful genre in the **2000s**.
- In the **2010s**, **Sci-Fi** came back as the most successful genre.
- In the **2020s**, **Adventure** is still very popular and leads in success.

This shows how different genres have been the most successful at different times, depending on what audiences preferred during each decade.




2. What genre consistently has the most "successes"? What genre used to reliably produced "successes" and has fallen out of favor? 

```{r}
library(ggplot2)
library(dplyr)

# Suppress warnings globally
options(warn = -1)

# Step 1: Define the rating threshold for successful movies
threshold_rating <- 7.5

# Step 2: Filter the data to include only successful movies from 1990 onwards
successful_movies <- TITLE_RATINGS %>%
  inner_join(TITLE_BASICS, by = "tconst") %>%
  filter(averageRating >= threshold_rating, as.numeric(startYear) >= 1990)

# Step 3: Group by genre and year, calculate cumulative count
successful_movies_by_genre <- successful_movies %>%
  mutate(startYear = as.numeric(startYear)) %>%
  separate_rows(genres, sep = ",") %>%
  group_by(genres, startYear) %>%
  summarize(success_count = n(), .groups = 'drop') %>%
  arrange(genres, startYear) %>%
  group_by(genres) %>%
  mutate(cumulative_success = cumsum(success_count))

# Step 4: Select top genres based on cumulative success
top_genres <- successful_movies_by_genre %>%
  group_by(genres) %>%
  summarize(total_cumulative_success = max(cumulative_success)) %>%
  arrange(desc(total_cumulative_success)) %>%
  slice(1:5) %>%
  pull(genres)

# Step 5: Filter the data for the top 5 genres and plot
plot_data_top_genres <- successful_movies_by_genre %>%
  filter(genres %in% top_genres)

# Step 6: Create a clearer plot
ggplot(plot_data_top_genres, aes(x = startYear, y = cumulative_success, color = genres, group = genres)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2, shape = 21, fill = "white", stroke = 0.5) +
  geom_text(data = plot_data_top_genres %>% group_by(genres) %>% filter(startYear == max(startYear)),
            aes(label = genres), vjust = -0.5, size = 3.5) +  # Add genre labels only at the end
  labs(
    title = "Cumulative Number of Successful Movies by Top 5 Genres (1990-2000)",
    x = "Year",
    y = "Cumulative Count of Successful Movies"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),  # Center title
    legend.position = "none"  # Remove legend since labels are used
  ) +
  scale_color_viridis_d(option = "plasma")




```  

### Summary of Genre Success Over Time

**Historical Genre Successes by Decade**:
   - **Animation** dominated from the **1930s to 1950s** but has fallen out of favor in recent decades.
   - **Biography** was successful in the **1960s**, while **Sci-Fi** gained prominence in the **1970s**.
   - **Adventure** has led from the **1980s to the 2020s**, with **Sci-Fi** showing growth since the 2000s.

**Current Genre Performance (Since 2010)**:
   - **Drama** has produced the most movies but has an average success rate.
   - **Biography** has a higher success rate per movie, despite fewer productions.
   - **Thriller** shows strong success per movie, even with fewer releases than Drama.

**Genre That Fell Out of Favor**:
   - **Animation**, which was once a dominant genre, especially in the mid-20th century, has seen its influence decline in recent years.

**Conclusions**:
   - **Adventure** has consistently produced successes across decades.
   - **Animation**, despite its early dominance, has fallen out of favor.
   - **Sci-Fi** has risen in popularity, especially in recent decades.

This overview highlights **Adventure's** long-standing success, **Animation's** decline, and **Sci-Fi's** modern rise.



3. What genre has produced the most “successes” since 2010? Does it have the highest success rate or does it only have a large      number of successes because there are many productions in that genre?
  


```{r}

library(ggplot2)
library(dplyr)

# Define a rating threshold for successful movies
threshold_rating <- 7.5

# Step 1: Filter the data to include only successful movies from any year onwards
successful_movies <- TITLE_RATINGS %>%
  inner_join(TITLE_BASICS, by = "tconst") %>%
  filter(averageRating >= threshold_rating)

# Step 2: Group by genre and year, calculate cumulative count of successful movies
successful_movies_by_genre <- successful_movies %>%
  mutate(startYear = as.numeric(startYear)) %>%   # Ensure startYear is numeric
  separate_rows(genres, sep = ",") %>%            # Split multiple genres into separate rows
  group_by(genres, startYear) %>%
  summarize(success_count = n(), .groups = 'drop') %>%  # Count successful movies per genre and year
  arrange(genres, startYear) %>%
  group_by(genres) %>%
  mutate(cumulative_success = cumsum(success_count))    # Calculate cumulative sum for each genre

# Step 3: Capture cumulative value up to 1990 for each genre
cumulative_up_to_1990 <- successful_movies_by_genre %>%
  filter(startYear < 1990) %>%
  group_by(genres) %>%
  summarize(total_up_to_1990 = max(cumulative_success, na.rm = TRUE))

# Step 4: Filter data from 1990 onwards and add the cumulative value up to 1990
successful_movies_1990_onwards <- successful_movies_by_genre %>%
  filter(startYear >= 1990) %>%
  left_join(cumulative_up_to_1990, by = "genres") %>%
  mutate(cumulative_success = cumulative_success + total_up_to_1990)

# Step 5: Rank genres by total cumulative success from 1990 onwards
final_cumulative_success <- successful_movies_1990_onwards %>%
  group_by(genres) %>%
  summarize(total_cumulative_success = max(cumulative_success)) %>%
  arrange(desc(total_cumulative_success))

# Step 6: Split the genres into three equal groups based on cumulative success
n <- nrow(final_cumulative_success)
split_size <- floor(n / 3)

# Top-performing genres
top_genres <- final_cumulative_success %>% 
  slice(1:split_size) %>% 
  pull(genres)

# Middle-performing genres
middle_genres <- final_cumulative_success %>%
  slice((split_size + 1):(2 * split_size)) %>% 
  pull(genres)

# Lower-performing genres
lower_genres <- final_cumulative_success %>%
  slice((2 * split_size + 1):n) %>%
  pull(genres)

# Step 7: Plot the three groups of genres separately, starting from 1990

# Plot 1: Top-performing genres
top_genres_plot <- ggplot(successful_movies_1990_onwards %>% filter(genres %in% top_genres), 
       aes(x = startYear, y = cumulative_success, color = genres, group = genres)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Yearly Growth of Successful Movies - Top Genres (1990 Onwards)",
    x = "Year",
    y = "Cumulative Count of Successful Movies"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

# Plot 2: Middle-performing genres
middle_genres_plot <- ggplot(successful_movies_1990_onwards %>% filter(genres %in% middle_genres), 
       aes(x = startYear, y = cumulative_success, color = genres, group = genres)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Yearly Growth of Successful Movies - Middle Genres (1990 Onwards)",
    x = "Year",
    y = "Cumulative Count of Successful Movies"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

# Plot 3: Lower-performing genres
lower_genres_plot <- ggplot(successful_movies_1990_onwards %>% filter(genres %in% lower_genres), 
       aes(x = startYear, y = cumulative_success, color = genres, group = genres)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(
    title = "Yearly Growth of Successful Movies - Lower Genres (1990 Onwards)",
    x = "Year",
    y = "Cumulative Count of Successful Movies"
  ) +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Display the plots
top_genres_plot
middle_genres_plot
lower_genres_plot



```


## Genre Successes Since 2010

Since 2010, **Drama** has produced the most successful movies, mainly due to the large number of productions in this genre. However, the **success rate** (average success per movie) for Drama is moderate, comparable to genres like **Thriller** and **Biography**. 

On the other hand, **Biography** has fewer productions but a significantly higher success rate per movie. This means that, while there are fewer Biography films, they tend to perform better individually compared to Drama films.

In conclusion, while Drama leads in terms of the total number of successful movies, other genres like Biography and Thriller achieve higher success rates, indicating that the number of movies is not always reflective of individual success.


4. What genre has become more popular in recent years?


```{r}

library(ggplot2)
library(dplyr)

# Define success threshold and filter the data for successful movies only
threshold_rating <- 7.5

# Updated valid genres list, now including "Documentary"
valid_genres <- c("Action", "Adventure", "Animation", "Biography", "Comedy", 
                  "Crime", "Documentary", "Drama", "Family", "Fantasy", 
                  "Film-Noir", "History", "Horror", "Music", "Musical", 
                  "Mystery", "Romance", "Sci-Fi", "Sport", "Thriller", 
                  "War", "Western")

# Function to filter movies for the selected time period and valid genres
filter_movies <- function(start_year, end_year) {
  TITLE_BASICS %>%
    filter(titleType == "movie", !is.na(startYear), as.numeric(startYear) >= start_year, as.numeric(startYear) <= end_year) %>%
    inner_join(TITLE_RATINGS, by = "tconst") %>%
    separate_rows(genres, sep = ",") %>%
    filter(genres %in% valid_genres)  # Filter valid genres
}

# Function to plot average success rate for each period
plot_success_rate <- function(period_name, start_year, end_year) {
  successful_movies <- filter_movies(start_year, end_year)
  
  # Calculate total number of movies and successful movies in each genre
  genre_summary <- successful_movies %>%
    group_by(genres) %>%
    summarize(total_movies = n(),
              successful_movies = sum(averageRating >= threshold_rating)) %>%
    mutate(success_rate = successful_movies / total_movies) %>%
    arrange(desc(success_rate)) %>%
    filter(total_movies > 0) %>%  # Ensure at least one movie in the genre
    slice_head(n = 10)  # Select top 10 genres
  
  # Plot
  ggplot(genre_summary, aes(x = reorder(genres, -success_rate), y = success_rate, fill = genres)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = scales::percent(success_rate, accuracy = 0.1)), vjust = -0.5) +
    labs(
      title = paste("Average Success Rate for Top 10 Genres (", period_name, ")"),
      x = "Genres",
      y = "Average Success Rate"
    ) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# Periods to analyze
periods <- list(
  "1900-1950" = c(1900, 1950),
  "1950-1980" = c(1950, 1980),
  "1980-2000" = c(1980, 2000),
  "2000-2020" = c(2000, 2020)
)

# Generate plots for all periods and display them
for (period_name in names(periods)) {
  period <- periods[[period_name]]
  print(plot_success_rate(period_name, period[1], period[2]))
}



```

# Movie Genre Success Over Time

Movie genre success has changed a lot over the years, reflecting shifts in what audiences enjoy. Here's a breakdown of the most successful genres from 1900 to 2020, divided into four periods.

## 1900 to 1950

Between 1900 and 1950, **Animation (19.4%)** and **Documentary (18.6%)** were the most successful genres. Audiences enjoyed both animated films and factual storytelling, showing a mix of entertainment and learning.

## 1950 to 1980

From 1950 to 1980, genres like **Western (46.7%)** and **War (44.1%)** were at the top. People were drawn to action-packed stories about the frontier and war, reflecting an era of adventure and heroism.

## 1980 to 2000

In the 1980 to 2000 period, **Documentary (39.9%)** became the most successful, with **History** and **Music** also doing well. Audiences started to focus more on real-life stories and educational content.

## 2000 to 2020

Between 2000 and 2020, **Documentary (34.8%)** and **Biography (30.3%)** continued to grow in popularity. These genres show a clear shift toward real-life and factual storytelling. On the other hand, **Animation** and **Drama**, which used to be popular, are now less successful.

## Conclusion: Which Genre Has Grown in Popularity?

In recent years, **Documentary** and **Biography** have clearly become more popular, leading the success charts from 2000 to 2020. Audiences are showing a strong preference for content that tells real-world stories and explores real lives, while genres like Animation and Drama have seen a drop in success.



# Task 1: Select a Genre for Your Next Project

**Selected Genre: Action/Sci-Fi with Superpowers**

This project is a remake of a **Resident Evil** movie, but with a war theme and powerful superhuman abilities for the main characters. The genre is **Action/Sci-Fi**, blending intense action scenes with superpowers. The story will be set during the war in Ukraine, leading to an epic battle for Crimea and beyond.

# Task 2: Identify Successful Personnel in the Genre

**Director: Paul W.S. Anderson (Director of *Resident Evil*)**  
- **Why Him?**: Paul W.S. Anderson directed several *Resident Evil* movies and knows how to create action-packed films with strong female leads. His experience in action and sci-fi makes him the perfect choice for this project.
- **Notable Films**: *Resident Evil* series, *Mortal Kombat*, *Event Horizon*

**Lead Actor: Keanu Reeves**  
- **Why Keanu?**: Keanu Reeves is well-known for his roles in *John Wick* and *The Matrix*. He’s famous for being a kind and generous person in real life, despite personal struggles. Keanu will play **Ben**, a leader who gains Matrix-like superpowers, making him a strong and moral hero.
- **Notable Films**: *John Wick*, *The Matrix*

**Lead Actress: Milla Jovovich**  
- **Why Milla?**: Milla is a Ukrainian-born actress and action star, perfect for the role of **Elena**, a scientist with superhuman powers. Her action experience in *Resident Evil* and her connection to Ukraine make her ideal for the role. Her superpowers in this movie will be like “Resident Evil on steroids,” making her an unstoppable force.
- **Notable Films**: *Resident Evil* series, *The Fifth Element*

---

# Task 3: Find a Classic Movie to Remake

We will remake **Resident Evil: Apocalypse** (2004). In the original movie, Alice (Milla Jovovich) fights to survive in a city overrun by a deadly virus. In this version, the story is set in war-torn Ukraine, where the main characters use their superpowers to fight back and reclaim Crimea, continuing their journey to liberate the whole of Ukraine and even Moscow.

---

# Task 4: Write and Deliver Your Pitch

### Elevator Pitch:

*The Battle for Crimea* is an action-packed remake of *Resident Evil: Apocalypse*. Directed by Paul W.S. Anderson, the movie stars Keanu Reeves as **Ben**, a kind and brave leader who gains Matrix-like superpowers, and Milla Jovovich as **Elena**, a Ukrainian scientist whose superpowers are like “Resident Evil on steroids.” Together, they form a romantic bond and use their combined powers to reclaim Crimea. Their mission doesn’t stop there; they continue the fight to liberate Ukraine and eventually push toward Moscow, bringing a thrilling and epic conclusion to their journey. With intense action, superhuman abilities, and a powerful story of war and love, this movie will captivate audiences worldwide.

---

# Plot: *The Battle for Crimea* (Remake of *Resident Evil: Apocalypse*)

The story begins in modern-day Ukraine, where the region of **Crimea** is under siege by Russian forces. **Ben** (Keanu Reeves) is a leader who helps protect civilians. Known for his kindness and strength, Ben has recently gained Matrix-like superpowers, making him incredibly strong, fast, and able to outsmart the enemy.

**Elena** (Milla Jovovich), a Ukrainian scientist, is kidnapped by Russian forces and used in a secret experiment. The experiment gives her powers far beyond those in *Resident Evil*—making her an unstoppable force. Her abilities allow her to control her surroundings, move with incredible speed, and fight with unmatched strength.

Elena escapes and joins forces with Ben. Together, they form a powerful team, both having superhuman abilities. As they reclaim Crimea, they develop a deep romantic connection. Their love and unity strengthen their resolve as they lead a resistance to liberate Ukraine.

But their mission doesn’t stop with Crimea. As they gain momentum, they push further into enemy territory, continuing to free Ukrainian cities, and the movie builds toward an epic showdown in Moscow. Their final battle is not just for their homeland but for the future of freedom.

---

# Why This Team Works:

- **Paul W.S. Anderson** has directed action-packed and sci-fi movies before, making him the right fit to lead this project.
- **Keanu Reeves**, known for his kindness and strong action roles, will shine as Ben, a Matrix-like hero who fights for good.
- **Milla Jovovich**, a Ukrainian-born actress, brings authenticity and power to the role of Elena, a super-powered heroine whose abilities are like “Resident Evil on steroids.”

Their powerful partnership, thrilling action, and emotional journey to liberate Ukraine and beyond will create a movie that captures audiences and leaves a lasting impact.


